module Example;

import Stdlib.Prelude open hiding {+};

import Stdlib.Data.Nat.Ord as Nat;
import Stdlib.Data.Nat as Nat;

import Stdlib.Data.Int.Ord open;
import Stdlib.Data.Int open;
import Data.List open;
import Data.String open;
import Data.Int open;

import Test.QuickCheckTest as QC open using {Fun; mkFun; module Fun};

prop-reverseDoesNotChangeLength : Fun (List Int) Bool :=
  mkFun \ {xs := length (reverse xs) Nat.== length xs};

prop-reverseReverseIsIdentity : Fun (List Int) Bool :=
  mkFun \ {xs := eqListInt xs (reverse (reverse xs))};

prop-tailLengthOneLess : Fun (List Int) Bool :=
  mkFun
    \ {xs :=
      null xs
        || ofNat (length (tail xs)) == intSubNat (length xs) 1};

prop-splitAtRecombine : Fun Nat (Fun (List Int) Bool) :=
  mkFun
    \ {n :=
      mkFun
        \ {xs :=
          case splitAt n xs of {lhs, rhs :=
            eqListInt xs (lhs ++ rhs)}}};

prop-mergeSumLengths
  : Fun (List Int) (Fun (List Int) Bool) :=
  mkFun
    \ {xs :=
      mkFun
        \ {ys :=
          length xs Nat.+ length ys
            Nat.== length (merge ordIntI xs ys)}};

prop-partition : Fun (List Int) (Fun (Fun Int Bool) Bool) :=
  mkFun
    \ {xs :=
      mkFun
        \ {pFun :=
          let
            p : Int -> Bool := Fun.fun pFun;
          in case partition p xs of {lhs, rhs :=
            all p lhs
              && not (any p rhs)
              && eqListInt (sortInt xs) (sortInt (lhs ++ rhs))}}};

prop-distributive
  : Fun Int (Fun Int (Fun (Fun Int Int) Bool)) :=
  mkFun
    \ {a :=
      mkFun
        \ {b :=
          mkFun
            \ {fFun :=
              let
                f : Int -> Int := Fun.fun fFun;
              in f (a + b) == f a + f b}}};

prop-add-sub : Fun Int (Fun Int Bool) :=
  mkFun \ {a := mkFun \ {b := a == a + b - b}};

prop-add-sub-bad : Fun Int (Fun Int Bool) :=
  mkFun \ {a := mkFun \ {b := a == 2}};

prop-gcd-bad : Fun Int (Fun Int Bool) :=
  mkFun \ {a := mkFun \ {b := gcd a b > 1}};

gcdNoCoprimeTest : QC.Test :=
  QC.mkTest "no integers are coprime" prop-gcd-bad;

partitionTest : QC.Test :=
  QC.mkTest
    "partition: recombination of the output equals the input"
    prop-partition;

testDistributive : QC.Test :=
  QC.mkTest
    "all functions are distributive over +"
    prop-distributive;

reverseLengthTest : QC.Test :=
  QC.mkTest
    "reverse preserves length"
    prop-reverseDoesNotChangeLength;

reverseReverseIdTest : QC.Test :=
  QC.mkTest
    "reverse of reverse is identity"
    prop-reverseReverseIsIdentity;

splitAtRecombineTest : QC.Test :=
  QC.mkTest
    "splitAt: recombination of the output is equal to the input list"
    prop-splitAtRecombine;

mergeSumLengthsTest : QC.Test :=
  QC.mkTest
    "merge: sum of the lengths of input lists is equal to the length of output list"
    prop-mergeSumLengths;

tailLengthOneLessTest : QC.Test :=
  QC.mkTest
    "tail: length of output is one less than input unless empty"
    prop-tailLengthOneLess;

main : IO :=
  readLn
    \ {seed :=
      QC.runTestsIO
        100
        (stringToNat seed)
        [partitionTest; reverseLengthTest; reverseReverseIdTest; splitAtRecombineTest; mergeSumLengthsTest; tailLengthOneLessTest]};
