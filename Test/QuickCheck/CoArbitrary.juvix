module Test.QuickCheck.CoArbitrary;

import Data.Random open;
import Data.Int open;
import Stdlib.Prelude open;
import Test.QuickCheck.Gen open;
import Stdlib.Data.Int.Ord open;

import Stdlib.Data.Nat as Nat;
import Stdlib.Data.Nat.Ord as Nat;

-- | A perturbation of a generator associated with a type B
trait
type CoArbitrary (A : Type) (B : Type) :=
  mkCoarbitrary {coarbitrary : Gen B -> A -> Gen B};

binaryDigits : Nat -> List Nat
  | n :=
    let
      terminating
      go : Nat -> List Nat
        | n :=
          if (n Nat.== 0) nil (Nat.mod n 2 :: go (Nat.div n 2));
    in reverse (go n);

perturb : Int -> StdGen -> StdGen
  | n rand0 :=
    let
      vary : Bool -> StdGen -> StdGen
        | b g :=
          let
            splitG : StdGen Ã— StdGen := stdSplit g;
          in if b (snd splitG) (fst splitG);
      terminating
      digitsParity : List Bool :=
        map (x in binaryDigits (abs n))
          x Nat.== 0;
    in for (rand := vary (n < 0) rand0) (b in digitsParity)
         vary b rand;

instance
coarbitraryIntInt : CoArbitrary Int Int :=
  mkCoarbitrary
    \ {g n := mkGen \ {rand := Gen.run g (perturb n rand)}};

coarbitraryIntIntHof : CoArbitrary Int (Int -> Int) :=
  mkCoarbitrary
    \ {g n := mkGen \ {rand := Gen.run g (perturb n rand)}};

instance
coarbitraryIntBool : CoArbitrary Int Bool :=
  mkCoarbitrary
    \ {g n := mkGen \ {rand := Gen.run g (perturb n rand)}};

instance
coarbitraryListInt : CoArbitrary (List Int) Int :=
  mkCoarbitrary
    \ {g xs :=
      mkGen
        \ {rand := Gen.run g (foldr perturb (perturb 0 rand) xs)}};
