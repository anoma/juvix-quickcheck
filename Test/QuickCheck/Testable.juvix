module Test.QuickCheck.Testable;

import Stdlib.Prelude open;
import Data.Random open;
import Test.QuickCheck.Arbitrary open;
import Test.QuickCheck.CoArbitrary open;
import Test.QuickCheck.Result open;
import Test.QuickCheck.Property open;
import Test.QuickCheck.Gen open;

--- A conversion from a Type A to a ;Property;
trait
type Testable (A : Type) :=
  mkTestable {toProp : A -> Property};

forAll {A T : Type} {{Show A}} {{Testable T}}
  : Gen A -> (A -> T) -> Property
  | g prop :=
    mkProperty
      (mkGen
        \ {rand :=
          let
            srand : StdGen Ã— StdGen := stdSplit rand;
            rand1 : StdGen := fst srand;
            rand2 : StdGen := snd srand;
            arg : A := Gen.run g rand1;
            subProp : Property := Testable.toProp (prop arg);
            res : Result := runProp subProp rand2;
          in overFailure
            res
            \ {(failure s cs) := failure s (Show.show arg :: cs)}});

instance
testableProperty : Testable Property := mkTestable id;

instance
testableResult : Testable Result :=
  mkTestable \ {r := mkProperty (mkGen (const r))};

instance
testableBool : Testable Bool :=
  let
    toResult : Bool -> Result
      | b := if b success (fail (failure 0 nil));
  in mkTestable \ {b := Testable.toProp (toResult b)};

testableFunction {A T} {{Show A}} {{Arbitrary A}} {{Testable
  T}} : Testable (A -> T) :=
  mkTestable \ {f := forAll Arbitrary.gen f};

testableFunction' {A T} {{Testable T}} {{Show
  A}} {{Arbitrary A}} : Testable (A -> T) := testableFunction;

testableFunction2 {A B C} {{Arbitrary A}} {{Show
  A}} {{Arbitrary B}} {{Show B}} {{Testable C}}
  : Testable (A -> B -> C) :=
  testableFunction' {{testableFunction}};

testableHof1 {A B C D} {{Show A}} {{Arbitrary A}} {{Testable
  D}} {{Arbitrary C}} {{CoArbitrary B C}}
  : Testable (A -> (B -> C) -> D) :=
  testableFunction'
    {{testableFunction
      {{showableFunction}}
      {{arbitraryFunction}}}};

testableHof2 {A B C D E} {{Show A}} {{Arbitrary A}} {{Show
  B}} {{Arbitrary B}} {{Testable E}} {{Arbitrary
  D}} {{CoArbitrary C D}}
  : Testable (A -> B -> (C -> D) -> E) :=
  testableFunction' {{testableHof1}};

showableFunction {A B : Type} : Show (A -> B) :=
  mkShow (const "function");
