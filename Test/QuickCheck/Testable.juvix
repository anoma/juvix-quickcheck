module Test.QuickCheck.Testable;

import Stdlib.Prelude open;
import Data.Random open;
import Test.QuickCheck.Arbitrary open;
import Test.QuickCheck.CoArbitrary open;
import Test.QuickCheck.Result open;
import Test.QuickCheck.Property open;
import Test.QuickCheck.Gen open;

--- A conversion from a Type A to a ;Property;
type Testable (A : Type) :=
  | testable : (A -> Property) -> Testable A;

toProp : {A : Type} -> Testable A -> A -> Property
  | (testable f) := f;

forAll
  : {A : Type}
    -> {T : Type}
    -> Show A
    -> Testable T
    -> Gen A
    -> (A -> T)
    -> Property
  | {A} {T} (mkShow to-str) (testable asProp) g prop :=
    property
      (gen
        \ {rand :=
          let
            srand : StdGen Ã— StdGen := stdSplit rand;
            rand1 : StdGen := fst srand;
            rand2 : StdGen := snd srand;
            arg : A := runGen g rand1;
            subProp : Property := asProp (prop arg);
            res : Result := runProp subProp rand2;
          in overFailure
            res
            \ {(failure s cs) := failure s (to-str arg :: cs)}});

testableProperty : Testable Property := testable id;

testableResult : Testable Result :=
  testable \ {r := property (gen (const r))};

testableBool : Testable Bool :=
  let
    toResult : Bool -> Result
      | b := if b success (fail (failure 0 nil));
  in testable \ {b := toProp testableResult (toResult b)};

type Argument (A : Type) :=
  | argument : Show A -> Arbitrary A -> Argument A;

testableFunction
  : {A : Type}
    -> {T : Type}
    -> Argument A
    -> Testable T
    -> Testable (A -> T)
  | (argument s (arbitrary g)) t :=
    testable \ {f := forAll s t g f};

argumentInt : Argument Int :=
  argument IntTraits.Show arbitraryInt;

argumentNat : Argument Nat :=
  argument NatTraits.Show arbitraryNat;

argumentList : {A : Type} -> Argument A -> Argument (List A)
  | (argument s a) :=
    argument (ListTraits.Show s) (arbitraryList a);

showableFunction : {A B : Type} -> Show (A -> B) :=
  mkShow (const "function");

argumentListInt : Argument (List Int) :=
  argumentList argumentInt;

argumentFunction
  : {A : Type}
    -> {B : Type}
    -> CoArbitrary A B
    -> Arbitrary B
    -> Argument (A -> B)
  | coArb arb :=
    argument showableFunction (arbitraryFunction coArb arb);

argumentIntInt : Argument (Int -> Int) :=
  argumentFunction coarbitraryIntInt arbitraryInt;

argumentIntIntInt : Argument (Int -> Int -> Int) :=
  case argumentIntInt
    | argument _ arbIntInt :=
      argumentFunction coarbitraryIntIntHof arbIntInt;

testableBinaryInt : Testable (Int -> Int -> Bool) :=
  testableFunction
    argumentInt
    (testableFunction argumentInt testableBool);

testableListInt : Testable (List Int -> Bool) :=
  testableFunction (argumentList argumentInt) testableBool;

testableListIntListInt
  : Testable (List Int -> List Int -> Bool) :=
  testableFunction
    (argumentList argumentInt)
    testableListInt;

testableNatListInt : Testable (Nat -> List Int -> Bool) :=
  testableFunction argumentNat testableListInt;

testableHofIntBool : Testable ((Int -> Bool) -> Bool) :=
  let
    arg : Argument (Int -> Bool) :=
      argumentFunction coarbitraryIntBool arbitraryBool;
  in testableFunction arg testableBool;

testableListIntHofIntBool
  : Testable (List Int -> (Int -> Bool) -> Bool) :=
  testableFunction
    (argumentList (argumentInt))
    testableHofIntBool;

testableHofIntInt : Testable ((Int -> Int) -> Bool) :=
  let
    arg : Argument (Int -> Int) :=
      argumentFunction coarbitraryIntInt arbitraryInt;
  in testableFunction arg testableBool;

testableIntIntHofIntInt
  : Testable (Int -> Int -> (Int -> Int) -> Bool) :=
  testableFunction
    argumentInt
    (testableFunction argumentInt testableHofIntInt);

testableHofIntIntListIntListInt
  : Testable
    ((Int -> Int -> Int) -> List Int -> List Int -> Bool) :=
  testableFunction
    argumentIntIntInt
    (testableFunction
      argumentListInt
      (testableFunction argumentListInt testableBool));
