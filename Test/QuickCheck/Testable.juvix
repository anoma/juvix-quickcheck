module Test.QuickCheck.Testable;

import Stdlib.Prelude open;
import Data.Random open;
import Test.QuickCheck.Arbitrary open;
import Test.QuickCheck.CoArbitrary open;
import Test.QuickCheck.Result open;
import Test.QuickCheck.Property open;
import Test.QuickCheck.Gen open;
import Test.QuickCheck.Fun open;

--- A conversion from a Type A to a ;Property;
trait
type Testable (A : Type) :=
  mkTestable {toProp : A -> Property};

forAll {A T : Type} {{Show A}} {{Testable T}}
  : Gen A -> (A -> T) -> Property
  | g prop :=
    mkProperty
      (mkGen
        \ {rand :=
          let
            srand : StdGen Ã— StdGen := stdSplit rand;
            rand1 : StdGen := fst srand;
            rand2 : StdGen := snd srand;
            arg : A := Gen.run g rand1;
            subProp : Property := Testable.toProp (prop arg);
            res : Result := runProp subProp rand2;
          in overFailure
            res
            \ {(failure s cs) := failure s (Show.show arg :: cs)}});

instance
testableProperty : Testable Property := mkTestable id;

instance
testableResult : Testable Result :=
  mkTestable \ {r := mkProperty (mkGen (const r))};

instance
testableBool : Testable Bool :=
  let
    toResult : Bool -> Result
      | b := if b success (fail (failure 0 nil));
  in mkTestable \ {b := Testable.toProp (toResult b)};

-- Instance uses Fun wrapper because Testable (A -> T) is not currently supported by the compiler.
-- https://github.com/anoma/juvix/issues/2371
instance
testableFunction {A T} {{Show A}} {{Arbitrary A}} {{Testable
  T}} : Testable (Fun A T) :=
  mkTestable \ {f := forAll Arbitrary.gen (Fun.fun f)};

instance
showableFunction {A B : Type} : Show (Fun A B) :=
  mkShow (const "function");
